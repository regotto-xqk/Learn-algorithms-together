package main.java.greed;

/**
 * 11.18 每日一题
 * 题目:
 * 在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
 * 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
 * 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。
 *
 * 样例:
 * 输入:
 * gas  = [1,2,3,4,5]
 * cost = [3,4,5,1,2]
 * 输出: 3
 * 解释:
 * 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
 * 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
 * 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
 * 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
 * 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
 * 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
 * 因此，3 可为起始索引。
 *
 * 题解:
 * 1.使用贪心策略, 枚举每个点, 从当前点走一圈, 看能不能回到起点 O(n^2), 若当前点不能走一圈, 那该点之后的点, 必然不能走, 可跳过, 实现优化
 * 2.使用单调队列, 从题目可以看出, 要保证从起点能走到终点, 则起点到终点之间所有值的前缀和的最小值要大于 0, 问题转化为求前缀和的最小值
 * @author regotto
 */
public class Lc134GasStation {

    /**
     * 使用贪心,
     * @param g
     * @param c
     * @return
     */
    public int canCompleteCircuit(int[] g, int[] c) {
        int n = g.length;
        for (int i = 0, j = 0; i < n;) {
            int l = 0;
            // 从 i 位置往后遍历 n 个点, l 记录走完 i ~ i+n 后剩余油量
            for (j = 0; j < n; j++) {
                int k = (i + j) % n;
                l += g[k] - c[k];
                if (l < 0) break;
            }
            if (j == n) return i;
            // i 走到 j 就出现不能走一圈的情况, 也说明, i ~ j 之间的点也不能走完
            i += j + 1;
        }
        return -1;
    }

}
